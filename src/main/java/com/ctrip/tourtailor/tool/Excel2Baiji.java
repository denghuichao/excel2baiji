package com.ctrip.tourtailor.tool;


import com.ctrip.tourtailor.utils.CollectionUtil;
import com.ctrip.tourtailor.utils.StringUtil;
import com.google.common.collect.Lists;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.*;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * Created by hcdeng on 2017/8/9.
 */
public class Excel2Baiji {

    private static final String FILE_HEAD = "include 'BaijiCommonTypes.bjsc'\n" +
            "include 'BaijiMobileCommonTypes.bjsc'\n" +
            "namespace java 'com.ctrip.tourtailor.contract'\n" +
            "namespace csharp '%s.Client'\n\n";

    private static final String STATEMENT = "/*This file is automatically generated by excel2baiji, developed by hcdeng*/\n\n";

    private static final String CHECK_HEALTH_INTER = "    BaijiCommonTypes.CheckHealthResponseType checkHealth(BaijiCommonTypes.CheckHealthRequestType request);\n";

    private  List<Map<String, List<String[]>>> entityMap;
    private  List<Map<String, List<String>>> interMap;
    private  Set<String> unkownTypes;

    private  boolean isInEntity = false;
    private  boolean isInInterface = false;

    public static void main(String[] args) throws Exception {

        if (args.length != 2) {
            System.out.println("USEAGE: Excel2Baiji [INPUT_FILE] [OUTPUT_FILE]");
           System.exit(-1);
        }

        new Excel2Baiji().processExcel(args[0], args[1]);
    }

    public Excel2Baiji() {
        entityMap = new ArrayList<>();
        interMap = new ArrayList<>();
        unkownTypes = new HashSet<>();
    }

    public void processExcel(String filePath, String outFile) throws IOException {

        InputStream excelFileToRead = new FileInputStream(filePath);
        XSSFWorkbook wb = new XSSFWorkbook(excelFileToRead);

        IntStream.range(0, wb.getNumberOfSheets()).forEach(i -> processSheet(wb.getSheetAt(i)));

        excelFileToRead.close();

        Set<String> knownTypes = entityMap.stream().map(Map::keySet)
                .flatMap(Collection::stream).collect(Collectors.toSet());

        unkownTypes.stream().filter(e -> !knownTypes.contains(e)).forEach(this::addEmptyEntity);

        writeToFile(outFile, generateFileContent(outFile));
    }

    private void writeToFile(String outFile, String content) throws IOException {
        try(FileWriter writer = new FileWriter(new File(outFile))){
            writer.write(content);
            writer.close();
        }
    }

    private String generateFileContent(String outFile) {
        String shortFileName = getFileShortName(outFile);
        StringBuilder sb = new StringBuilder();
        //file headers
        sb.append(String.format(FILE_HEAD, shortFileName));
        sb.append(STATEMENT);

        //entity definition
        entityMap.stream().flatMap(m -> m.entrySet().stream())
                .forEach(e -> printEntity(e.getKey(),e.getValue(), sb));

        //service headers
        sb.append("@serviceName='" + shortFileName + "'\n");
        sb.append("@serviceNamespace='http://soa.ctrip.com/Tour/soa/" + shortFileName + "'\n");
        sb.append("service ").append(shortFileName).append("{\n");

        //service definition
        interMap.stream().flatMap(m -> m.entrySet().stream()).
                forEach(e -> printInterface(e.getKey(), e.getValue(), sb));


        sb.append(CHECK_HEALTH_INTER);
        sb.append("}\n");
        return sb.toString();
    }

    private void printEntity(String eName, List<String[]> fields, StringBuilder sb){
        sb.append("class " + eName + "{\n");//class define
        sb.append(fields.stream().map(e -> "    "+e[0]+" "+e[1]+";\n").collect(Collectors.joining("")));
        sb.append("}\n\n");
    }

    private void printInterface(String iName, List<String> params, StringBuilder sb){
        sb.append("    " + params.get(1) + " "); //return type
        sb.append(iName); // function name
        sb.append("(" + params.get(0) + " " + StringUtil.firstToLower(params.get(0)) + ");    \n"); //params
    }

    private void processSheet(XSSFSheet sheet) {
        isInEntity = false;
        isInInterface = false;

        String entityName = null;
        List<String[]> fields = null;

        String interName = null;
        List<String> interParams = null;
        String interComment = null;

        Iterator rows = sheet.rowIterator();
        while (rows.hasNext()) {
            XSSFRow row = (XSSFRow) rows.next();
            Iterator cells = row.cellIterator();
            while (cells.hasNext()) {
                String tag = cells.next().toString();
                if ("实体定义".equals(tag) || "接口名称".equals(tag)) {

                    checkAndAddEntity(entityName, fields);
                    checkAndAddInterface(interName, interParams, interComment);

                    if ("实体定义".equals(tag)) {
                        entityName = cells.next().toString();
                        fields = new ArrayList<>();
                        isInEntity = true;
                        rows.next();
                    } else{
                        interName = cells.next().toString();
                        interParams = new LinkedList<>();
                        XSSFRow nextRow = (XSSFRow) rows.next();
                        Iterator cCells = nextRow.cellIterator();
                        cCells.next();
                        interComment = cCells.next().toString();
                        isInInterface = true;
                        rows.next();
                    }
                    break;
                } else if (isInEntity && !tag.equals("") && fields != null) {
                    String fName = tag;
                    String fType = getBaijiType(cells.next().toString());
                    String content = cells.next().toString();
                    fields.add(new String[]{fType, fName, "//" + content});
                    break;
                } else if (isInInterface) {
                    cells.next();
                    String inParm = cells.next().toString();
                    if (StringUtil.isNotEmpty(inParm) && interParams != null)
                        interParams.add(inParm);
                    break;
                }
            }
        }

        checkAndAddEntity(entityName, fields);
        checkAndAddInterface(interName, interParams, interComment);
    }

    private void checkAndAddEntity(String entityName, List<String[]> fields){
        if (isInEntity) {
            Map<String, List<String[]>> map = new HashMap<>();
            map.put(entityName, new ArrayList<>(fields));
            entityMap.add(map);
            isInEntity = false;
        }
    }

    private void checkAndAddInterface(String interName, List<String> interParams, String interConment){
        if (isInInterface && CollectionUtil.isNotEmpty(interParams) && isValidIdentifier(interName)) {
            Map<String, List<String>> map = new HashMap<>();
            if (StringUtil.isNotEmpty(interConment))
                interParams.add("//" + interConment);

            map.put(interName, new ArrayList<>(interParams));
            interMap.add(map);
            isInInterface = false;
        }
    }


    private void addEmptyEntity(String ut) {
        List<String[]> emptyList = Lists.newArrayList();
        Map<String, List<String[]>> map = new HashMap<>();
        map.put(ut, emptyList);
        entityMap.add(map);
    }

    private boolean isValidIdentifier(String s) {
        return StringUtil.isNotEmpty(s) && s.matches("[a-zA-Z0-9_]+");
    }

    private String getFileShortName(String fileName) {
        return StringUtil.isEmpty(fileName) ? "null" : fileName.replaceFirst("\\..*$", "").replaceAll(".*/", "");
    }

    private String getBaijiType(String inType) {
        String[] tStrs = inType.split("(?<=[^a-zA-Z0-9_])|(?=[^a-zA-Z0-9_])");

        IntStream.range(0, tStrs.length).forEach(i -> tStrs[i] = verifyTypes(tStrs[i]));

        return String.join("", tStrs);
    }

    private String verifyTypes(String inType) {
        String type = StringUtil.isEmpty(inType) ? "null" : inType.toLowerCase();

        switch (type) {
            case "bool":case "boolean":return "bool";
            case "int":case "integer":
            case "int32":return "int";
            case "long":case "int64":return "long";
            case "string":case "chars":case "char":return "string";
            case "double":case "binary":case "byte":case "decimal":case "float":return type;
            case "short":case "int16":return "short";
            case "date":case "datetime":case "calender":return "datetime";
            case "list":return "list";
            case "map":return "map";
            case "responsestatustype":return "BaijiCommonTypes.ResponseStatusType";
            case "requestheadertype":return "BaijiMobileCommonTypes.MobileRequestHead";
            case "commonrequestype":return "BaijiMobileCommonTypes.CommonRequestType";
            default:if (isValidIdentifier(inType)) unkownTypes.add(inType);
                return inType;
        }
    }
}
